---
title: High Volume monitoring with Graphite
subtitle: Graphs Galore
author:
 - Владимир Витков
date: 2015.05.16 / Plovdivconf
titlepage-note: |
 Всеки бизнес има нужда от мониторинг. Всеки бизнес има нужда от гъвкав мониторинг който му позволява да си извади добри изводи. Днес ще ви разкажа как го постигнахме при нас.
...

## Кой е пред вас
 * Владимир
 * Системен Администратор
 * Привърженик на FOSS но не и зеалот
 * Експериментатор
 * Относително приятен човек за разговор\*

# Основи
Да положим основите

## Що е това мониторинг
 * Система/и които събират данни
 * Използва се от OPS
 * Използва се от бизнеса
 * използва се от мениджърите
 * Използва се за известяване

\note{
Мониторинг системите са необходимо зло. Без тях не знаем какво се случва в нашата система. С тях ... вече знаем че всичко е счупено и не добре.
Мониторинг системите се използват не само от администраторите и хората на смяна. Ползват се от бизнес мениджъри, от дирекни мениджъри, рекламисти, и кой ли още не.
Добрата мониторинг система се използва и за известяване.
}

## Защо ни трябва мониторинг
 * Без мониторинг сме слепи
 * Имаме ли капацитет
 * Държи ли се добре приложението ни
 * А имаме ли място
 * А колко плащаме за всичко
 * Има ли някой който ни атакува

\note{
Мониторинг системите имат множество приложения. Както за наблюдаване и проследяване на текущото състояние, така и за предсказване на бъдещо такова. Могат да бъдат много добър признак че нещо не е наред (някой ни атакува), да се позлват за изчисляване на сметки и още милиони неща.
}

## Какво е добър мониторинг
 * Там където ти трябва
 * Такъв който не ти пречи
 * Гъвкав за да може да се използва за различни цели
 * Лесен за ползване
 * Лесен за работа

\note{
Добрият мониторинг представлява ненатрапчива система която позволява свободна работа с нея. Позволява да бъде разширявана и не ти се пречка когато ти трябва. Гъвкав е от гледна точка на възможности и начини за употреба. И може би най важното удобен е както за системните администратори така и за не особенно запознатите хора.
}

## Що е това система за метрики
 * Част от мониторинг системите
 * Цифрово изражение на нещата
 * Централно място за предвиждания
 * ... и планиране
 * ... Следене на странности

\note{
Системите за метрики са необходими за да имаме цифрово изражение на нашата услуга. Основната им цел обикновенно е да се използват за планиране на бъдещо натоварване, анализ на текущото. Откриване на проблеми. ПРОДАЖБИ и какво ли още не.

Обикновенно системите за метрики са част от мониторинга, но могат да бъдат и отделни. Най-често се появяват като добавка към класическа система за мониторинг (нагиос) с цел да се събират и данни за производителността на системата. Могат също така да са интегрирани във самата система (какти) или просто да са нейна функционалност (какти).
}

## Трябват ли ни метрики
 * на кратко да
 * По нашироко
 	* Да разбира се
	* Освен ако нямаме дребен сайт с няколко посетителя дневно
	* ... и огромно количество хардуер да го движи
	* И тогава даже пак ни трябват

\note{
Метрики и мониторинг системи са винаги необходими. Няма как да минем без тях. Без значение колко малък или голям е бизнесът ни е абсолютно належащо да знаем неговото състояние. Било то прииходи и разходи, производителност, складова наличност или каквото се сетите
}

# Graphite

## Какво е Graphite
 * Йерархична система за събиране на метрики
 * Python
 * Бърза
 * Позволява използване за различни цели
 * Удобен интерфейс за експерименти
 * Фиксирано изискване на мястото*

\note{
Graphite e йерархична система за събиране на метрики. Написан е на питон. Може да бъде захранен с данни по различни начини. Доста бърза. С фиксирани изисквания за място (ако е помислено разумно). Има много удобен интерфейс за експерименти с вашите данни и е ужасно удобна при дизайн
}

## Защо Graphite
 * It's hip (nope)
 * It's fast and flexible (Hell yes)
 * Подкарва се бързо
 * Позволява много възможности

\note{
Избрали сме Graphite не защото е модерно а поради функционалността му
}

# The Plan

## Какво ще покажем
 * Събиране на данни от много машини
 * Обработка на данните
 * Методики за определяне структурата на метриките
 * Изграждане на надеждна система
 * Оптимизация на цялото нещо

\note{}

## Събиране на данни
 * POLL
 	* Центранел колектор(и)
	* Разпределени колектори
 * PUSH
 	* Разпределени или балансирани колектори
	* UDP is a friend

\note{
Има две основни архитектури. POLL или PULL базирана при която колекторите на данните питат за тях. Това не е особенно скалируемо тъй като колекторите рано или късно се претоварват. Другият вариант е PUSH архитектура при която клиентите докладват данните. Обикновенно имаме няколко колектора скрити зад балансер който разпределя натоварването. По този начин много по лесно разпределя натоварването. Също така не забравявйте разликата в цената на TCP и UDP. Да при UDP може да имате загуби но печелите скорост. Ако това не е приемливо работете с TCP.
}

## Събиране на данни
 * APP и OS
 * Collectd (client)
 * Collectd (server)
 * Graphite (a few/lot)
 * Има и други варианти

\note{
В моя конкретен случай приложенията и ОС-a докладват данните си на локален collectd процес където подлежат на буфериране при желание. От там се изпращат на централизирания collectd сървър. Той от своя страна ги подава на серия от graphite процеси които ги обработват докато най-накрая се окажат върху дисковете. Това не е единственият и вероятно не е и най-добрият начин, така че почетете.
}

## collectd.conf
~~~~~
LoadPlugin network
<Plugin Network>
	Listen "0.0.0.0" "3011"
</Plugin>
LoadPlugin write_graphite
<Plugin write_graphite>
	<Node "localhost">
		Host "localhost"
		Port "10001"
		Protocol "tcp"
		AlwaysAppendDS false
	</Node>
</Plugin>
~~~~~

\note{
Зареждаме необходимите плъгини (network и  write\_graphite) като ги конфигурираме съответно да слушат и да изпращат данните.
}

## Обработка на данните
 * Преименуване на данните
 * Агрегиране
 * Понижаване на точността (защо ли)
 * Други магии

\note{
След като получим данните може да ги подложим на обработа. Обработката в общия случай бива три вида. Преименуване на данните за да пасната на схемата на нашите метрики. Агрегиране на няколко метрики в една (сървъри). Понижаване на точността чрез усредняване на няколко поредни метрики. Основната цел на това усредняване (roll-up) е да се смести място. Отделно Graphite позволява дописване на функции с които може да се реализира каквото ви душа желае.
}

## Преименуване (rewrite-rules.conf)
От

~~~~~
prod.i-123.p_pi-cust:srv:inst.metric
~~~~~

До

~~~~~
prod.customer.service.instance.id.metric
~~~~~

\note{
Има случаи при които данните не идват във вид удобен за графит и цялото нещо трябва да се преименува. Много добър пример е когато данните идват от collectd. Collectd поддържа хост, плъгин, инстанция на плъгина. Ако структурата ви не съвпада с идеята обикновенно си добавяте къстъм сепаратори които в последстви трябва да си разпарсите. За целта се използва rewrite-rules.conf където има 2 секции (pre и post) като се използват в различни слЗа целта се използва rewrite-rules.conf където има 2 секции (pre и post) като се използват в различни случаи.
}

## Агрегиране (aggregation-rules.conf)
 * Правила за агрегиране на данни
 * OUT (freq) = method IN
`````
<srv>.<srvid>.all (20) = <srv>.<srvid>.x*.qps
`````

\note{
В случай че имате множество машини може да агрегирате данните за да не товарите фронтенда. Това се постига чрез aggregation-rules.conf
}

## Roll-UP (понижаване на точността)
 * Данни с висока точност са ни нужни за кратко време
 * Пести се дисково пространство
 * Улеснява изчертаването
 * По-полезни са на мениджмънт хората
 * storage-aggregation.conf

\note{
Данни с висока резолюция са полезни но за съжаление консумират доста пространство. Също така са трудни за представяне
}

## Структуриране на метриките
 * Измислете си схема и я следвайте
 * environment.application.instance.metric.dimension
 * production.retriever.high-prio.pages.per-second
 * Не се страхувайте да задълбаете
 * Изисквайте унифицирани метрики (min, avg, max, persec)
 * Blacklist и Whitelist
 * Не е грешка да кривнете.

\note{
Един от основните фактори за успеха/провала на тази ви система е структурирането на метриките ви. Подредете ги по начин който е удобен за вас и вашия бизнес. Ако приложение не може да ви даде метриките във вид който ви интересува помислете или да преименувате метриките от сървърна страна или да смените библиотеката/приложението. Не се страхувайте да нарушите схемата (поне в по ниските нива) ако това е смислено за случая. Настоявайте метрики да се генерират по определен начин и да се подават с определени имена (ще си спестите не малко главоболия). Не се притеснявайте да отхвърляте метрики.
}

# Цялостна система
\note{
Ще покажем как изглежда нашата система и защо е изградена по този начин.
}

## Изграждане на надеждна система
 * Много копия
 * Разпределено
 * Кешове
 * Възстановяване?
 * Тестове, тестове, тестове

\note{
За да бъде една система надеждна тя трябва да отговаря на няколко прости правила. Да може да се възстанови, да може да расте, и най-вече тези неща да се случват лесно. Основното в случая е да пазите повече от едно копие на данните си. Вярно може да са само метрики но си ги пазете. Организирайте разпределена система. Правете редовно тестове как се държи нещото при различни критични ситуации
}

## Изграждане на надеждна система (2)
 * Graphite е CPU ограничен
 * Превърнете го в ограничен по диск
 * Много кешове
 * Буфери
 * Опашки

\note{
По дизайн самият графит е ограничен до една процесорна нишка. Което сътветно го спъва в конфигурацията по подразбиране. За да избегнем това трябва да пуснем множество инстанции за да оползотворим всички налични процесори и постепенно да го превърнем в ограничен по диск. Имайте предвид че метода по който графит записва данните на диска води до не малко количество операции. За да се избегне това използвайте много кешове с либерални буфери и опашки. Друг трик е да вкарате графит в режим при който той записва данните пакетно (а не точка по точка). Като цяло това се случва почти от само себе си.
}

## Системата
![system-graph](images/grapher.png "Схема на цялата система")

\note{
Системата ни е изградена от N+1 броя нодове като данните между тя са разпределени със резервираност. Показан е опростен вариант със само 2 нода. Тази система поне според нашите скромни наблюдения спокойно може да понесе около 2000 метрики в секунда. Системата е изградена на множество нива с цел да може да се подменя/рестартира/разширява всяко едно ниво само за себе си.
Нивата които имаме са:
 * Главен колектор - collectd
 * Първичен relay - carbon-relay - използва се за осъществяване на репликация на данните и реализация на буфер
 * Вторичен relay - carbon-relay - използва се за бъдещо разширяване на системата и реализира буфер
 * агрегатор на данни - carbon-aggregator - използва се за пресмятане на някои стойности и пестене на диск + буфер
 * кешофе - carbon-cache - записват данните на диска
}

# Демонстрация
\note{
Малка демонстрация как работят нещата.
}

# Въпроси?
Въпроси?

\note{}

## Връзки
 * Слайдове: http://bit.ly/1JMShuv
 * Demo: http://bit.ly/1PIcMKF
 * mail: vvitkov@linux-bg.org
 * GPG: A162 1211 8ACB 4CC5

\note{}
